# 设计模式

## 创建型模式
1. 工厂模式: 在父类中提供一个创建对象的方法，允许之类决定实例化对象的类型；
1. 抽象工厂模式: 创建一系列相关的对象，无需指定其具体类
2. 生成器模式: 能够分步骤创建复杂的对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象；
3. 原型模式: 能够复制已有对象而又无需使用代码一代他们属性类；
4. 单例模式: 保证一个类只有一个实例，并提供一个访问该实例的全部节点；

## 结构型模式
1. 适配器模式: 让接口不兼容的对象能够相互作用;
2. 搭桥模式: 可将一个大类和一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。
3. 组合模式: 你可以使用它将对象组合成树状结构，并且能使用独立对象一样使用的；
4. 装修模式: 将对象放入包含行为的特殊封装对象中来为原对象保定新行为；
5. 外观模式: 能为程序库、框架或其他复杂类提供一个简单的接口；
6. 亨元模式: 它避免了在每一个对象中保存所有数据的方法，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多的对象；
7. 代理模式: 提供对象的替代品或站位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理；

## 行为模式
1. 责任链模式: 允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上下一个处理者。
2. 命令模式: 它可将请求转换为一个包含与请求相关的所有信息的独立对象。改转换让你能根据不同的请求将方法参数化、延迟请求执行或将其方放入队列中，且能实现可撤销操作。
3. 迭代模式: 让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中的所有元素
4. 中介者模式: 能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使他们通过一个中介者对象进行合作。
5. 备忘录模式: 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态；
6. 观察者模式: 允许你定义一种订阅机制，可在对象发生变化时通知多个“观察”该对象的对象；
6. 状态模式: 让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样；
7. 策略模式: 能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够互相替换；
8. 模版方法模: 在超类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤；
9. 访问者模式: 将算法与其他作用的对象隔离开来；